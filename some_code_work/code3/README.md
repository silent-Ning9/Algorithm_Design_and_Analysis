问题描述
给定一个高精度正整数n（有效位数≤240）和一个整数s，删除n中的s个数字后，剩下的数字按原左右次序组成一个新的正整数。目标是找到一种删除方案，使得剩下的数字组成的新数最小。

算法思路
本问题采用贪心算法解决，核心思想是：从左到右扫描数字，当遇到一个数字比它前面的数字小时，删除前面的数字，这样可以保证高位数字尽可能小。

算法步骤
1. 初始化
创建一个空字符串result用于存储最终结果

设置剩余删除次数remaining = s

2. 遍历处理每个数字
对于输入数字n的每一位数字digit：

循环条件：当还有删除次数(remaining > 0)、结果字符串不为空、且当前数字小于结果字符串最后一个数字时

循环操作：

从结果字符串末尾删除一个数字

剩余删除次数减1

将当前数字添加到结果字符串末尾

3. 处理剩余删除次数
如果遍历完成后仍有剩余删除次数，从结果字符串末尾删除相应数量的数字

4. 处理前导零
找到第一个非零数字的位置

如果所有数字都是零，返回"0"

否则，截取从第一个非零数字开始到末尾的子串

算法正确性证明
贪心选择性质
对于高位数字，删除较大的数字比删除较低位的数字对数值的影响更大。因此，我们应该优先确保高位数字尽可能小。

最优子结构
每次删除操作都是独立的，且每次删除都会使剩余数字更接近最优解。删除一个数字后，剩下的问题仍然是"删数问题"，只是规模减小了。

时间复杂度分析
每个数字最多被加入结果字符串一次和删除一次

时间复杂度：O(n)，其中n是输入数字的位数

空间复杂度：O(n)，用于存储结果字符串

示例演示
示例输入：
text
n = 178543
s = 4
执行过程：
处理'1' → result = "1"

处理'7' → result = "17" (7>1，不删除)

处理'8' → result = "178" (8>7，不删除)

处理'5' →

5<8，删除8 → result = "17", remaining = 3

5<7，删除7 → result = "1", remaining = 2

添加5 → result = "15"

处理'4' →

4<5，删除5 → result = "1", remaining = 1

添加4 → result = "14"

处理'3' →

3<4，删除4 → result = "1", remaining = 0

添加3 → result = "13"

最终结果：13
特殊情况处理
删除所有数字：如果s等于n的长度，返回"0"

前导零：删除前导零，除非结果全为零

非递减序列：如果数字已经是非递减顺序，从末尾删除s个数字